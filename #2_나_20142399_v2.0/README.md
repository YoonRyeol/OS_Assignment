# 부트로더 구현

## 1. 개요

이 과제는 부트로더를 이해하고 분석, 리얼모드에서 보호모드로 전환 과정을 이해, 부트로더에서 키보드 인터럽트를 이용한 커널을 선택하는 코드를 완성하는 것을 목표로 하는 과제이다.

 부트로더란 운영체제가 시동되기 이전에 미리 실행되면서 커널이 올바르게 시동되기 위해 필요한 모든 관련 작업을 마무리하고 최종적으로 운영 체제를 시동시키기 위한 목적을 가진 프로그램을 말한다.
 
 본 부트로더는 16bit의 리얼모드를 먼저 부팅한다. 리얼 모드는 가상메모리를 쓰지 않으며 사용되는 모든 segment와 offset이 물리적인 메모리 주소에 의해 가리켜진다. 이 모드에서 동작하는 모든 프로그램은 메모리의 모든 영역을 접근할 수 있으며 실제모드에서 사용할 수 있는 모든 명령어들을 사용할 수도 있다.
 
 보호모드는 시스템 소프트웨어가 다중작업, 가상메모리, 페이징, 그리고 응용 소프트웨어를 넘는 운영체제 제어능력을 높이기 위해 고안된 운영체제의 다른 기능들을 이용할 수 있게 도와준다. 일반적으로 CPU는 BIOS이후 리얼모드에서 보호모드로 전환이 되는데 이때 GDT등 부가적 정보가 필요하다.
 
 리얼모드에서 보호모드로 전환하는 과정은 다음과 같다. 먼저 세그먼트 디스크립터를 생성한다. 그리고 GDT정보를 생성을 하고 프로세서에 GDT정보를 설정한다. CR0 컨트롤 레지스터를 설정을 하고 jmp 명령으로 CS 세그먼트 셀렉터 변경과 보호모드로 전환을 한다. 그후 각종 세그먼트 셀렉터 및 스택을 초기화 하고 보호모드 커널을 실행한다. 
 
 ## 2. 상세설계
 
 ### 2-1. 구현 함수별 프로토타입
 
 #### 1. START

 이 부트로더가 제대로 실행되도록 함수 선언부를 건너뛰기 위한 프로시져 이다.
 
 #### 2. print_char
 
 이 부트로더에서 문자하나를 띄우기 위한 함수이다. int 0x10, ah 0x0E 인터럽트를 사용하여 구현하였다.
  
 #### 3. print_string
 
 문자열을 화면에 출력하기 위한 함수이다. si값을 증가시키고 print_char을 이용하여 해당 주소값에 해당하는 문자를 하나씩 출력하는 과정을 문자열의 끝까지 반복하여 출력한다.
 
 #### 4. RESET_CURSOR

 [0]을 [ ]로 덮어쓰기 위한 함수이다. 커서의 현재 위치를 받아오는 인터럽트, 커서의 위치를 설정하는 인터럽트와 print_string을 이용하였다. 
 
 #### 5. cls
 
  화면에 출력된 모든 문자를 지우는 함수이다.

 #### 6. BOOT1_LOAD
 
 기존에 구현된 리얼모드 부팅을 위한 프로시져이다.

#### 7. SELECT

 커널을 선택하기 위한 GUI를 출력하는 프로시져이다. print_string을 이용해 구현하였다.

#### 8. CURSOR_SSU1, CURSOR_SSU2, CURSOR_SSU3:
 
 N번 커널을 선택하기 위한 작업을 하는 프로시져이다. 각 섹터의 LBA 값을 이용하여 CHS 값으로 변환한다. 변환된 CHS 값을 cylinder, head, sector 변수에 넣어 추후에 KERNAL_LOAD 프로시져에서 로드할 수 있도록 한다. 또한 [O] 커서를 GUI에서 옮겨주는 역할을 수행한다.

#### 9. KERNEL_LOAD:
 
 기설정된 cylinder, head, sector값을 레지스터에 넣고 ah=2, int 0x13 인터럽트를 사용하여 커널을 로드한다. 
 
 ### 2-2. 전체 구성도
 
 ![image](https://user-images.githubusercontent.com/40683361/118363685-85f23480-b5d0-11eb-9b69-8be0d3d2a5f5.png)
 
다음은 본 과제의 프로그램 구성도이다.

 프로그램이 시작되면 먼저 BOOT1_LOAD로 리얼모드로 부팅을 한다. 그 뒤에 SELECT 단계에서 커널을 선택하기 위한 GUI를 화면에 띄어준다. 
 그 뒤에 화살표 방향키를 이용하여 CURSOR_SSU1, CURSOR_SSU2, CURSOR_SSU3를 이동하면서 KENEL_LOAD에서 사용할 변수 값을 변경해준다.
enter 키를 치면 선택한 커널의 정보를 가지고 KERNEL_LOAD로 가서 선택한 커널을 로드한다.

CURSOR_SSU‘X‘(’X‘는 1,2,3의 정수)에서 각 커널에 필요한 cylinder, head, sector 값을 설정을 하는데 MBR 테이블에 있는 LBA주소를 이용하여 각 cylinder, head, sector의 값을 계산을 한다. 
 각 변수의 값을 계산하는 식은 다음과 같다.
 
```
Cylinder = LBA / (HPC * SPT)
Head = (LBA / SPT) % HPC
Sector = (LBA % SPT) + 1
```

 HPC는 Head Per Cylinder의 약자이고 SPT는 Sector Per Track의 약자이다. 이들은 bochsrc파일에 명시되어 있다. 
 LBA와 해당 파라미터들을 이용하면 원하는 CHS 튜플을 얻을 수 있고 이를 알맞은 레지스터에 대입시켜서 인터럽트 해주면 원하는 커널을 로드할 수 있다. 

