# 스케줄러

## 1. 개요

본 과제는 SSUOS의 기존 스케줄러인 FIFO 스케줄러를 ULE 스케줄러로 바꾸어 구현하는 것이 목표이다.

 OS에서 모든 프로세스들은 실행을 시작하면서 자신이 필요로 하는 자원을 경쟁적으로 운영체제에 요구하는데 운영체제는 이들이 요청한 자원을 공평하게 할당하는 일을 수행한다. 이 일을 스케줄링이라 하며 이를 하는 프로세스를 스케줄러라고 한다. 스케줄러는 공정하게, 효율적으로, 기아상태가 발생하지 않도록, 그리고 비용을 줄이기 위해 자신의 일을 수행한다. 
 
 스케줄링의 유형에는 크게 두 가지가 있는데 하나는 Non-preemptive Scheduling, 다른 하나는 preemptive scheduling이다. Non-preemptive Scheduling은 비선점 스케줄링이라고도 하며 이는 한 프로세스가 프로세서 자원을 점유하게 되면 자신의 동작이 끝나지 않는 한 다른 프로세서에 의해 빼앗기지 않는 스케줄링 유형을 말한다. Preemptive 스케줄링은 선점 스케줄링이라고도 하며 이는 한 프로세스가 프로세서 자원을 점유하고 있더라도 스케줄링에 따라 다른 프로세스에 의해 자원을 빼앗기게 되는 스케줄링 유형을 말한다.
 
 스케줄러는 프로세스들의 정보를 담는 프로세스 구조체로부터 우선순위를 파악하여 가장 우선순위가 높은 프로세스를 다음 실행할 프로세스로 정하고 context switching을 하여 다음 프로세스를 실행시켜주게 되는데 이때 우선순위를 정하는 기준은 스케줄러의 유형에 따라 상이하다. 
 
 context switching은 문맥교환이라고도 하며 한 프로세스가 프로세서를 점유한 상태에서 다른 프로세스가 프로세서를 사용하도록 하기 위해, 이전의 PCB를 보관하고, 새로운 프로세스의 PCB를 적재하는 것을 말하는데 이때 PCB에 한 프로세스의 문맥이 기록되어 있다.
 
 ## 2. 상세설계
 
 ### 2-1. 구현 함수별 프로토타입
 
 + #### Proc.c

#### 1. runq

 본 과제에서 ULE 스케줄러를 구현함에 있어서 제일 먼저 해야하는 일은 runq를 구현하는 일이었다. runq는 프로세스의 우선순위에 따라 프로세스의 실행순서를 정렬하는 것과 더불어 먼저 실행을 요청한 프로세스를 먼저 실행시켜주는 것을 결합한 형태의 큐이다. runq는 25개의 리스트로 구성되어 있으며 프로세스들은 각 프로세스의 우선순위에 4를 나눠 나오는 몫의 값에 해당하는 인덱스를 가지는 runq의 리스트에 선입 선출의 형식으로 대기를 하게 된다. 기존의 SSUOS는 단순히 FIFO의 형식으로 스케줄링을 하였는데, 이때 스케줄링에 쓰인 rlist를 runq로 바꿔줘야 했기 때문에 rlist를 사용한 모든 함수를 runq에 맞게 수정하였다.


#### 2. init_proc()

 0번 프로세스를 실행하는 함수이다. runq를 구현하기 위해 runq의 모든 리스트를 초기화하고, 0번 프로세스를 runq의 알맞은 인덱스의 리스트에 넣는 것을 구현하였다.


#### 3. proc_create()

 프로세스가 새로이 실행될 때 호출되는 함수이다. 프로세스가 실행되고 runq에 담기도록 수정하였다


#### 4. proc_wake()

 프로세스가 sleep 상태에서 run상태로 전환시키기 위해 호출되는 함수이다. slist의 sleep상태의 프로세스가 일어날 시간이 되면 run으로 전환시킨다. runq에 맞게 수정하였다.


#### 5. proc_sleep()

 프로세스를 sleep상태로 전환시키기 위해 사용된다. PCB에 sleep상태에서 일어날 시간을 정해주는 것을 추가해 주었다.

#### 6. proc_unblock()

 프로세스의 상태를 run상태로 전환시킨다. runq에 맞게 구현하였다.
 
 
#### 7. kernel1_proc()

 1번 프로세스가 수행하는 함수이다. 140틱에서 I/O 처리를 위해 proc_sleep()을 호출하여 sleep상태로 전환하도록 설정하였다. 또한 200틱이 넘어가면 프로세스가 종료하도록 proc_end()를 사용하였다..


#### 8. kernel2_proc()

 2번 프로세스가 수행하는 함수이다. 100틱에서 I/O 처리를 위해 proc_sleep()을 호출한다. 120틱이 넘어가면 proc_end()를 호출해 프로세스를 종료한다.


#### 9. kernel3_proc()

 3번 프로세스가 수행하는 함수이다. 50틱, 100틱에서 I/O 처리를 위해 proc_sleep()을 호출한다. 150틱이 넘어가면 proc_end()를 호출해 프로세스를 종료한다.


#### 10. idle()
 
 OS가 제일 먼저 수행하는 프로세스이다. 0번 프로세스로 1,2,3번 프로세스를 먼저 호출하고 계속해서 스케줄러를 호출하게 된다. 3번 프로세스 호출하는 부분을 추가하였다.


#### 11. proc_getpos()

 프로세스의 우선순위와 인덱스 변수의 주소를 인자로 받아 인덱스 변수에 계산된 우선순위를 저장한다.


#### 12. recalculate_priority()

 명시에 제시된 priority = priority + time_slice/10 식을 구현하여 호출될 때 마다 프로세스의 우선순위를 계산하는 함수이다.

+ #### sched.c

#### 1. get_next_proc()

 스케줄러에서 다음 순서로 실행할 프로세스를 골라주는 함수이다. 명세에 따라 현재 프로세스가 0번이 아닐 경우, 0번 프로세스로 context switching하기 위해 0번 프로세스의 주소를 리턴한다.
 
 현재 프로세스가 0번 프로세스일 경우, 현재 runq에서 원소가 있는 리스트들 중 가장 우선순위가 높은 리스트의 맨 앞에 있는 원소의 주소값을 리턴한다. 리턴한 원소는 다음으로 실행할 프로세스가 된다. 


#### 2. schedule()

 프로세스를 스케줄하는 함수이다. 앞에서 구현한 runq에 있는 원소들을 우선순위 및 작업을 요청한 순서에 따라 스케줄한다.
 
 이 함수는 먼저 스케줄링의 대상이 되는 프로세스의 tick 증가를 막기 위해 프로세스 구조체의 simple_lock을 1로 설정한다. 그리고 intr_disable() 함수를 사용하여 인터럽트의 실행을 막는다. 그 뒤 proc_wake()를 사용하여 sleep 상태에서 run상태로 전환되야 할 프로세스들을 깨운다. 그 뒤 프로세스 출력을 위해서 runq에 있는 원소들을 pid 오름차순 순서로 출력한다. 그 후 get_next_proc()을 호출하여 다음 프로세스를 정하고 다음으로 실행될 프로세스를 출력한다. 다음 프로세스 실행에 앞서 현재 프로세스의 멤버 변수들을 초기화 하고 switch_process()를 호출하여 context_switching을 한다. 그리고 intr_enable()을 실행하여 인터럽트의 실행을 허용하고 동작을 마친다.


+ #### interrupt.c

#### 1. timer_handler()

 이 함수는 프로세스의 틱 및 현재 OS의 틱을 세어주는 함수이다. 현재 프로세스의 구조체에 simple_lock이 설정되어 있지 않다면 time_used와 time_slice를 세어주고 그렇지 않은 경우는 프로세스의 tick변수들을 세어주지 않는다. 
 
 또한 이 함수는 30틱마다 현재 프로세스의 우선순위를 재계산하여 runq에 다시 넣어주는 작업을 수행한다. recalculate_priority()를 실행하여 우선순위를 갱신하고 list_remove()와 list_push_back()을 호출하여 알맞은 runq의 리스트에 다시 넣어준다.
 
 
### 2-2. 전체 구성도

![image](https://user-images.githubusercontent.com/40683361/118364723-a15f3e80-b5d4-11eb-8ff8-0537f5276fdc.png)

 전체적인 시스템의 구성은 다음과 같다. 스케줄링이 될 때 마다 runq에서 get_next_proc()을 통해 다음 순서가 될 프로세스를 선별한다. 그리고 context_switching()을 통하여 cur_process를 60틱마다 바꾸어준다.
 
 현재 실행되고 있는 프로세스가 I/O 상태가 될 때 proc_sleep()을 호출하여 slist에 넣어주고 sleep상태로 바꾸어 준다. 그리고 설정된 시간이 지나면 proc_wake()를 호출하여 다시 runq로 넣어주게 된다.

