# System Call

## 1. 개요

본 과제는 목표는 시스템 콜을 이해하는 것이다. 시스템 콜을 이해하기 위해 본 과제에서 수행해야 하는 항목은 다음과 같다. 기존 open 시스템 콜 함수에 O_APPEND, O_TRUNC 기능을 추가하고 fcntl 시스템 콜을 구현 및 추가하는 것이 본 과제에서 수행해야 하는 항목이다.

 OS에서 시스템 콜 함수는 사용자 영역에서 커널 영역의 기능을 사용할 수 있게 해주는 인터페이스이고 크게 프로세스 제어, 파일 조작, 장치 관리, 정보 유지, 통신의 기능을 한다.
 
 SSUOS에서 시스템 콜 함수가 동작하는 과정은 다음과 같다. 먼저 intr_init()에서 시스템 콜을 처리하기 위한 syscall_handler()를 IDT에 등록한다. 그리고 각 시스템 콜을 처리하기 위한 시스템 콜 테이블을 정의한다.
 
 그 이후 시스템 콜 함수가 사용이 되는 과정은 다음과 같다. 각 시스템 콜 함수는 그 함수가 부르는 커널 영역에서 사용되는 함수가 시스템 콜 테이블에 정의되어있다. 시스템 콜 함수는 시스템 콜로 테이블에 정의된 함수를 호출한다. 커널 영역의 함수는 커널 영역에서 사용자가 요청한 작업을 수행하고 결과 값을 다시 시스템 콜에 리턴한다. 리턴된 값은 시스템 콜 함수에 의해 사용자 영역에 리턴됨으로써 일련의 작업이 종료된다. 이러한 과정을 SSUOS 코드를 보며 분석하고 직접 구현하면서 시스템 콜을 이해할 수 있다.
 
 또한 본 과제에서 open()의 O_APPEND, O_TRUNC 플래그를 구현하고 fcnt()의 플레그들을 구현하면서 필연적으로 파일 속성을 다루는 구조체인 inode 구조체를 다루게 된다. inode 구조체는 파일을 관리하기 위한 객체로 파일이 새로 생성되면 만들어지는데 파일의 모든 정보를 관리한다. open()의 플래그들을 구현하기 위해 inode의 속성값을 직접 변경시키는 작업을 하게 된다.
 
 ## 2. 상세 설계
 
 ### 2-1. 구현 함수별 프로토타입 및 기능 설명
 
 - #### fcntl()
 
 본 과제에서 fcntl()에 대해서 구현해야 했던 항목은 fcntl()을 syscall()을 이용해서 직접 구현하고, fcntl()을 시스템 콜 핸들러 테이블에 등록하여 호출 시 커널 영역의 do_fcntl()를 호출할 수 있도록 연결 시키는 것, 커널 영역의 do_fcntl()에서 F_GETFL, F_SETFL, F_DUPFL 플래그를 구현하는 것이였다. 
 
 과제를 제일 먼저 시작할 때, ssuos를 컴파일 하면 컴파일이 되지 않으며 fcntl()을 참조할 수 없다는 오류 메시지를 볼 수 있었다. 이는 시스템 콜 함수를 구현한 syscall.c에 fcntl()이 있지 않았기 때문이다. 따라서 맨 먼저 fcntl()을 구현해야 했다. 
 
 커널 영역의 함수를 호출하기 위하여 먼저 init_syscall()에 REGSYS()를 이용하여 시스템 콜 핸들러 테이블에 do_syscall()함수 영역의 do_fcntl을 등록시켜주고 명세에 나온대로 fcntl()의 원형을 선언한 뒤 이 함수가 핸들레 테이블을 참조할 수 있도록 syscall3()를 사용하여 테이블을 참조할 수 있도록 하였다. 인자가 3개이기 때문에 syscall3()를 사용하였다. 
 
 그 다음으로 해야하는 것은 do_fcntl() 함수에서 플래그들을 구현하는 것이다.
 
 F_DUPFD 플래그는 인자로 받은 파일 디스크립터 fd를 arg에 복사하는 것이다. 이는 단순히 arg에 fd가 가리키는 파일 구조체의 주소를 저장해줌으로써 간단하게 구현할 수 있었다.
 
 F_GETFL 플래그는 목표가 되는 파일의 디스크립터를 fd에 인자로 넣어 해당 파일의 플래그 정보를 얻는 것이다. 이는 file.h에 정의된 ssufile 구조체의 flags 변수의 값을 리턴해주는 방식으로 구현하였다.
 
 F_SETFL 플래그는 목표가 되는 파일의 디스크립터를 fd에 인자로 넣고 arg로 플래그를 받아 해당 파일에 arg로 받은 플래그를 설정해 주는 기능을 한다. 먼저 파일 디스크립터가 가리키는 파일 구조체에 or 비트 연산을 통하여 플래그를 저장해주고, 현재 파일의 inode, 플래그 정보를 file_open()에 인자로 주어 새로운 파일 구조체를 만들었다. 그리고 이 파일 구조체를 기존의 파일 디스크립터가 포인터 하도록 하여 해당 플래그의 기능을 구현하였다.
 
- #### open()

 open()의 O_APPEND와 O_TRUNC 플래그를 구현하는 것이 이번 과제의 항목이었다. 이 플래그를 구현하기 위해서는 file.c의 file_open()에서 주어진 코드에 O_APPEND와 O_TRUNC를 구현해야 했다.

file_open()의 기능은 open()에서 호출한 do_open()에서 넘겨준 목표가 되는 파일의 inode와 flag들, 그리고 mode를 이용하여 새로운 파일 구조체를 만들고 파일 구조체를 플래그에 알맞게 초기화 해주는 기능을 한다. 
 
O_APPEND의 기능은 기존의 파일을 open()하였을 때, 파일의 끝부터 write()할 수 있도록 파일의 상태를 설정해주는 플래그이다. 이를 구현하기 위해서, 현재 파일의 offset의 정보를 담고 있다고 생각되는 pos변수에 inode에서 파일 크기를 저장하고 있는 sn_size의 값을 할당해주고, 파일 구조체의 flag 정보에 O_APPEND를 or 연산하여 정보를 등록해 줌으로써 구현할 수 있었다.

O_TRUNC는 기존의 파일을 open()하였을 때, 해당 파일이 기존에 가지고 있던 모든 정보를 지우도록 하는 플래그이다. 이를 위해 inode의 sn_size 변수를 0으로 만들어 주었고, 파일 구조체가 이 inode를 가리키도록 하고, 파일구조체의 플래그 변수에 O_TRUNC를 or연산하여 플래그를 등록해줌으로써 해당 플래그를 구현하였다.

### 2-2. 전체 구성도

- #### fcntl()

![image](https://user-images.githubusercontent.com/40683361/118364180-4fb5b480-b5d2-11eb-805b-1896acd97e7c.png)

fcntl()의 대략적인 구성은 다음과 같다. 사용자 영역에서 fcntl()을 호출하게 되면 fcntl()안의 syscall3()함수가 호출되게 된다. 이는 시스템 콜 핸들러 테이블에 미리 등록된 do_fcntl()을 확인하고 do_fcntl()을 호출하게 된다. do_fcntl()이 호출되면 입력받은 플래그에 따라 함수가 다른 역할을 수행하게 된다. F_DUPFL를 받았다면 arg를 통해 파일디스크립터를 복사하여 리턴하게 되고 F_GETFL을 받았다면 파일의 현재 플래그 상태를 리턴받게 되고, F_SETFL를 받았다면 
변경되고 난 뒤의 현재 파일의 플래그 상태를 리턴받게 된다. 세 플래그가 아닌 다른 플래그를 입력받으면 –1을 리턴받는다. 

 do_fcntl()를 자신을 호출한 syscall3()로 리턴 값을 반환하게 되고 syscall3()는 사용자 영역의 fcntl()에 다시 그 값을 반환하게 된다.
 
 - #### open()
 
![image](https://user-images.githubusercontent.com/40683361/118364231-8f7c9c00-b5d2-11eb-9511-d48fb44e4bde.png)

다음은 open()의 구성도이다. 
사용자 영역에서 open()을 호출하면 open()안에 있는 syscall2()가 시스템 콜 핸들러 테이블에 등록된 do_open()을 호출한다. 호출된 do_open()은 먼저 파일 디스크립터를 더 등록할 수 있는지 확인하고 없다면 –1을 리턴, 할 수 있다면 inode_open()을 호출한다. inode_open()은 open()의 대상이 되는 파일에 대해서 기존에 존재하던 파일이라면 그 파일의 inode를 반환해주고 그렇지 않다면 inode를 새로 만들어 반환해 준다.

그 후 해당 파일이 디렉토리 파일인지 확인하고 디렉토리 파일이라면 –1을 리턴하고 그렇지 않다면 file_open()을 호출한다. file_open()에서는 먼저 파일 디스크립터를 더 등록할 수 있는지 확인하고 그렇지 않다면 –1을 리턴한다.    더 등록할 수 있다면 먼저 해당 파일의 정보를 담기위한 파일 구조체를 생성하고 기존에 있던 inode 구조체를 파일 구조체의 inode 변수가 가리키도록 해준다.

O_APPEND 플래그가 인자로 들어왔다면 O_APPEND에 플래그를 위한 과정을 수행해주고, O_TRUNC 플래그가 인자로 들어왔다면 그에 맞는 과정을 수행해준다 그 후 파일 디스크립터를 do_open()으로 리턴해준다. do_open()은 syscall2()로 파일디스크립터를 리턴해주고 syscall2()는 open()으로 파일 디스크립터를 리턴해준다.

open()은 사용자 영역에 파일 디스크립터를 리턴함으로써 모든 수행이 마무리된다.

